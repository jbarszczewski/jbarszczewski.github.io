<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>Rust CLI Game of Life tutorial - PART 1 |</title><meta name=Description content><meta property="og:title" content="Rust CLI Game of Life tutorial - PART 1"><meta property="og:description" content="Intro Hi! If you&rsquo;re here that means you are curious about Rust and/or want to learn it. I&rsquo;ve written my first Rust tutorial, Rust + Actix + CosmosDB (MongoDB) tutorial api, back in June 2020. This time I&rsquo;ve decided I will try to cover another use case for Rust which is CLI. To make it more interesting it will be implementation of Game of Life based on Official Rust WebAssembly tutorial enhanced with some user interaction logic."><meta property="og:type" content="article"><meta property="og:url" content="https://jbarszczewski.com/posts/rust-cli-game-part1/"><meta property="article:published_time" content="2021-02-04T18:39:52+00:00"><meta property="article:modified_time" content="2021-02-04T18:39:52+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Rust CLI Game of Life tutorial - PART 1"><meta name=twitter:description content="Intro Hi! If you&rsquo;re here that means you are curious about Rust and/or want to learn it. I&rsquo;ve written my first Rust tutorial, Rust + Actix + CosmosDB (MongoDB) tutorial api, back in June 2020. This time I&rsquo;ve decided I will try to cover another use case for Rust which is CLI. To make it more interesting it will be implementation of Game of Life based on Official Rust WebAssembly tutorial enhanced with some user interaction logic."><meta name=application-name content="jbarszczewski"><meta name=apple-mobile-web-app-title content="jbarszczewski"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://jbarszczewski.com/posts/rust-cli-game-part1/><link rel=prev href=https://jbarszczewski.com/posts/rust-actix-webapi/><link rel=stylesheet href=/lib/normalize/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Rust CLI Game of Life tutorial - PART 1","inLanguage":"en","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/jbarszczewski.com\/posts\/rust-cli-game-part1\/"},"genre":"posts","wordCount":1214,"url":"https:\/\/jbarszczewski.com\/posts\/rust-cli-game-part1\/","datePublished":"2021-02-04T18:39:52+00:00","dateModified":"2021-02-04T18:39:52+00:00","publisher":{"@type":"Organization","name":"Author"},"author":{"@type":"Person","name":"Author"},"description":""}</script></head><body data-header-desktop data-header-mobile><script>(window.localStorage&&localStorage.getItem('theme')?localStorage.getItem('theme')==='dark':(''==='auto'?window.matchMedia('(prefers-color-scheme: dark)').matches:''==='dark'))&&document.body.setAttribute('theme','dark');</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title=jbarszczewski class=header-logo>jbarszczewski</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>Posts </a><a class=menu-item href=/tags/>Tags </a><a class=menu-item href=/categories/>Categories </a><span class="menu-item delimiter"></span><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme"><i class="fas fa-adjust fa-fw"></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title=jbarszczewski class=header-logo>jbarszczewski</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><a class=menu-item href=/posts/>Posts</a><a class=menu-item href=/tags/>Tags</a><a class=menu-item href=/categories/>Categories</a><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme">
<i class="fas fa-adjust fa-fw"></i></a></div></div></header><main class=main><div class="container content-article theme-classic"><div class=toc id=toc-auto><div class=toc-title>Contents</div><div class=toc-content id=toc-content-auto></div></div><div class=header-post><div class=post-title><div class=post-all-meta><div class=breadcrumbs><a href=/>Home </a>/ <a href=/>Rust CLI Game of Life tutorial - PART 1</a></div><h1 class="single-title animated flipInX">Rust CLI Game of Life tutorial - PART 1</h1><div class=post-meta><div class=post-meta-line>&nbsp;&nbsp;&nbsp;&nbsp;<i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time class=timeago datetime=2021-02-04>2021-02-04</time>&nbsp;&nbsp;&nbsp;&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;1214 words
&nbsp;&nbsp;&nbsp;&nbsp;<i class="far fa-clock fa-fw"></i>&nbsp;6 minutes</div></div></div></div></div><article class="single toc-start"><div class="content-block content-block-first content-block-position"><div class=post><div class="details toc" id=toc-static data-kept><div class="details-summary toc-title"><span>Contents</span>
<span><i class="details-icon fas fa-angle-right"></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents></nav></div></div><h1 id=intro>Intro</h1><p>Hi! If you&rsquo;re here that means you are curious about Rust and/or want to learn it. I&rsquo;ve written my first Rust tutorial, <a href=https://dev.to/jbarszczewski/rust-actix-cosmosdb-mongodb-tutorial-api-17i5 target=_blank rel="noopener noreffer">Rust + Actix + CosmosDB (MongoDB) tutorial api</a>, back in June 2020. This time I&rsquo;ve decided I will try to cover another use case for Rust which is CLI. To make it more interesting it will be implementation of Game of Life based on <a href=https://rustwasm.github.io/docs/book/game-of-life/rules.html target=_blank rel="noopener noreffer">Official Rust WebAssembly tutorial</a> enhanced with some user interaction logic.</p><p>This is beginner tutorial, yet I still highly recommend going through official <a href=https://github.com/rust-lang/rustlings target=_blank rel="noopener noreffer">rustlings tutorial</a>.</p><p>&ldquo;Final&rdquo; code can be found on my <a href=https://github.com/jbarszczewski/cli-game-of-life target=_blank rel="noopener noreffer">github repo</a></p><p>Let&rsquo;s start!</p><h1 id=create-the-universe>Create The Universe</h1><p>After creating new project something like <code>cargo new cli-game-of-life</code> (or <code>cargo init</code> if you&rsquo;re already in correct directory) open your favourite editor and&mldr; ignore main.rs for now. We&rsquo;re gonna create game logic module first, so go ahead and create a new file <code>src/game.rs</code>. As mentioned in before, I will base the logic on official wasm tutorial so if you&rsquo;ve done it before it will be very familiar. Let&rsquo;s start with defining an enum that will represent single cell in our game universe:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=cp>#[derive(Copy, Clone, Debug, Eq, PartialEq)]</span><span class=w>
</span><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>enum</span> <span class=nc>Cell</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>	</span><span class=n>Dead</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>0</span><span class=p>,</span><span class=w>
</span><span class=w>	</span><span class=n>Alive</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p><code>derive</code> attribute will tell the compiler to provide basic implementation of passed traits so that we can assign cells with enum values and compare them.</p><p><strong>Note:</strong> We could use simple bool value as well but enum will give us better readability while having the same memory footprint.</p><p>Our game universe is defined as follows:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>pub</span><span class=w> </span><span class=k>struct</span> <span class=nc>Universe</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>	</span><span class=n>width</span>: <span class=kt>u32</span><span class=p>,</span><span class=w>
</span><span class=w>	</span><span class=n>height</span>: <span class=kt>u32</span><span class=p>,</span><span class=w>
</span><span class=w>	</span><span class=n>cells</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=n>Cell</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>Now we can start implementing functions for our game. Let&rsquo;s start with a handy constructor that will initialize Universe with given size and assign Cells starting values and <code>set_cells</code> function that will accept an array of cells coordinates and set them to Alive state.</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>impl</span><span class=w> </span><span class=n>Universe</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>	</span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>new</span><span class=p>(</span><span class=n>width</span>: <span class=kt>u32</span><span class=p>,</span><span class=w> </span><span class=n>height</span>: <span class=kt>u32</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Universe</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>		</span><span class=n>Universe</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>			</span><span class=n>width</span>: <span class=nc>width</span><span class=p>,</span><span class=w>
</span><span class=w>			</span><span class=n>height</span>: <span class=nc>height</span><span class=p>,</span><span class=w>
</span><span class=w>			</span><span class=n>cells</span>: <span class=nc>vec</span><span class=o>!</span><span class=p>[</span><span class=n>Cell</span>::<span class=n>Dead</span><span class=p>;</span><span class=w> </span><span class=p>(</span><span class=n>width</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>height</span><span class=p>)</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=kt>usize</span><span class=p>],</span><span class=w>
</span><span class=w>		</span><span class=p>}</span><span class=w>
</span><span class=w>	</span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>	</span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>set_cells</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>cells</span>: <span class=kp>&amp;</span><span class=p>[(</span><span class=kt>u32</span><span class=p>,</span><span class=w> </span><span class=kt>u32</span><span class=p>)])</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>		</span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=n>row</span><span class=p>,</span><span class=w> </span><span class=n>col</span><span class=p>)</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=n>cells</span><span class=p>.</span><span class=n>iter</span><span class=p>().</span><span class=n>cloned</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>			</span><span class=kd>let</span><span class=w> </span><span class=n>idx</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>get_index</span><span class=p>(</span><span class=n>row</span><span class=p>,</span><span class=w> </span><span class=n>col</span><span class=p>);</span><span class=w>
</span><span class=w>			</span><span class=bp>self</span><span class=p>.</span><span class=n>cells</span><span class=p>[</span><span class=n>idx</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Cell</span>::<span class=n>Alive</span><span class=p>;</span><span class=w>
</span><span class=w>		</span><span class=p>}</span><span class=w>
</span><span class=w>	</span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>	</span><span class=k>fn</span> <span class=nf>get_index</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>row</span>: <span class=kt>u32</span><span class=p>,</span><span class=w> </span><span class=n>column</span>: <span class=kt>u32</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>usize</span> <span class=p>{</span><span class=w>
</span><span class=w>		</span><span class=p>(</span><span class=n>row</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>width</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>column</span><span class=p>)</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=kt>usize</span><span class=w>
</span><span class=w>	</span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>The <code>get_index</code> is a helper fumction that will translate Universe coordinates into index of coresponding cell in <code>cells</code> array.</p><p>Next, we will implement <code>Display</code> trait for easy printing out current state of our game:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>fmt</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>impl</span><span class=w> </span><span class=n>fmt</span>::<span class=n>Display</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>Universe</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>	</span><span class=k>fn</span> <span class=nf>fmt</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>f</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=n>fmt</span>::<span class=n>Formatter</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>fmt</span>::<span class=nb>Result</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>		</span><span class=k>for</span><span class=w> </span><span class=n>line</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>cells</span><span class=p>.</span><span class=n>as_slice</span><span class=p>().</span><span class=n>chunks</span><span class=p>(</span><span class=bp>self</span><span class=p>.</span><span class=n>width</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=kt>usize</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>			</span><span class=k>for</span><span class=w> </span><span class=o>&amp;</span><span class=n>cell</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=n>line</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>				</span><span class=kd>let</span><span class=w> </span><span class=n>symbol</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>if</span><span class=w> </span><span class=n>cell</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>Cell</span>::<span class=n>Dead</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=sc>&#39;◻&#39;</span><span class=w> </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=sc>&#39;◼&#39;</span><span class=w> </span><span class=p>};</span><span class=w>
</span><span class=w>				</span><span class=n>write</span><span class=o>!</span><span class=p>(</span><span class=n>f</span><span class=p>,</span><span class=w> </span><span class=s>&#34;{}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>symbol</span><span class=p>)</span><span class=o>?</span><span class=p>;</span><span class=w>
</span><span class=w>			</span><span class=p>}</span><span class=w>
</span><span class=w>			</span><span class=n>write</span><span class=o>!</span><span class=p>(</span><span class=n>f</span><span class=p>,</span><span class=w> </span><span class=s>&#34;\n&#34;</span><span class=p>)</span><span class=o>?</span><span class=p>;</span><span class=w>
</span><span class=w>		</span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>		</span><span class=nb>Ok</span><span class=p>(())</span><span class=w>
</span><span class=w>	</span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>Perfect! Now we have something to run. Head over to your <code>main.rs</code> and replace all with the following content:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>mod</span> <span class=nn>game</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>	</span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>game</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>game</span>::<span class=n>Universe</span>::<span class=n>new</span><span class=p>(</span><span class=mi>5</span><span class=p>,</span><span class=w> </span><span class=mi>5</span><span class=p>);</span><span class=w>
</span><span class=w>	</span><span class=n>game</span><span class=p>.</span><span class=n>set_cells</span><span class=p>(</span><span class=o>&amp;</span><span class=p>[(</span><span class=mi>2</span><span class=p>,</span><span class=w> </span><span class=mi>1</span><span class=p>),</span><span class=w> </span><span class=p>(</span><span class=mi>2</span><span class=p>,</span><span class=w> </span><span class=mi>2</span><span class=p>),</span><span class=w> </span><span class=p>(</span><span class=mi>2</span><span class=p>,</span><span class=w> </span><span class=mi>3</span><span class=p>)]);</span><span class=w>
</span><span class=w>	</span><span class=n>print</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;{}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>game</span><span class=p>);</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>And run your prohect with <code>cargo run</code>. Ok it works! Of course, nothing is really happening here so let&rsquo;s do another step and add the <code>tick</code> function to our code:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>tick</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>	</span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>next</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>cells</span><span class=p>.</span><span class=n>clone</span><span class=p>();</span><span class=w>
</span><span class=w>	</span><span class=k>for</span><span class=w> </span><span class=n>row</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=mi>0</span><span class=p>..</span><span class=bp>self</span><span class=p>.</span><span class=n>height</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>		</span><span class=k>for</span><span class=w> </span><span class=n>col</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=mi>0</span><span class=p>..</span><span class=bp>self</span><span class=p>.</span><span class=n>width</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>			</span><span class=kd>let</span><span class=w> </span><span class=n>idx</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>get_index</span><span class=p>(</span><span class=n>row</span><span class=p>,</span><span class=w> </span><span class=n>col</span><span class=p>);</span><span class=w>
</span><span class=w>			</span><span class=kd>let</span><span class=w> </span><span class=n>cell</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>cells</span><span class=p>[</span><span class=n>idx</span><span class=p>];</span><span class=w>
</span><span class=w>			</span><span class=kd>let</span><span class=w> </span><span class=n>live_neighbours</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>live_neighbour_count</span><span class=p>(</span><span class=n>row</span><span class=p>,</span><span class=w> </span><span class=n>col</span><span class=p>);</span><span class=w>
</span><span class=w>			</span><span class=n>next</span><span class=p>[</span><span class=n>idx</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>match</span><span class=w> </span><span class=p>(</span><span class=n>cell</span><span class=p>,</span><span class=w> </span><span class=n>live_neighbours</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>				</span><span class=p>(</span><span class=n>Cell</span>::<span class=n>Alive</span><span class=p>,</span><span class=w> </span><span class=n>x</span><span class=p>)</span><span class=w> </span><span class=k>if</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>Cell</span>::<span class=n>Dead</span><span class=p>,</span><span class=w>
</span><span class=w>				</span><span class=p>(</span><span class=n>Cell</span>::<span class=n>Alive</span><span class=p>,</span><span class=w> </span><span class=mi>2</span><span class=p>)</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=p>(</span><span class=n>Cell</span>::<span class=n>Alive</span><span class=p>,</span><span class=w> </span><span class=mi>3</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>Cell</span>::<span class=n>Alive</span><span class=p>,</span><span class=w>
</span><span class=w>				</span><span class=p>(</span><span class=n>Cell</span>::<span class=n>Alive</span><span class=p>,</span><span class=w> </span><span class=n>x</span><span class=p>)</span><span class=w> </span><span class=k>if</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=mi>3</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>Cell</span>::<span class=n>Dead</span><span class=p>,</span><span class=w>
</span><span class=w>				</span><span class=p>(</span><span class=n>Cell</span>::<span class=n>Dead</span><span class=p>,</span><span class=w> </span><span class=mi>3</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>Cell</span>::<span class=n>Alive</span><span class=p>,</span><span class=w>
</span><span class=w>				</span><span class=p>(</span><span class=n>otherwise</span><span class=p>,</span><span class=w> </span><span class=n>_</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>otherwise</span><span class=p>,</span><span class=w>
</span><span class=w>			</span><span class=p>};</span><span class=w>
</span><span class=w>		</span><span class=p>}</span><span class=w>
</span><span class=w>	</span><span class=p>}</span><span class=w>
</span><span class=w>	</span><span class=bp>self</span><span class=p>.</span><span class=n>cells</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>next</span><span class=p>;</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>fn</span> <span class=nf>live_neighbour_count</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>row</span>: <span class=kt>u32</span><span class=p>,</span><span class=w> </span><span class=n>column</span>: <span class=kt>u32</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>u8</span> <span class=p>{</span><span class=w>
</span><span class=w>	</span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>count</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w>
</span><span class=w>	</span><span class=k>for</span><span class=w> </span><span class=n>delta_row</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=p>[</span><span class=bp>self</span><span class=p>.</span><span class=n>height</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=mi>1</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=mi>1</span><span class=p>].</span><span class=n>iter</span><span class=p>().</span><span class=n>cloned</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>		</span><span class=k>for</span><span class=w> </span><span class=n>delta_col</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=p>[</span><span class=bp>self</span><span class=p>.</span><span class=n>width</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=mi>1</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=mi>1</span><span class=p>].</span><span class=n>iter</span><span class=p>().</span><span class=n>cloned</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>			</span><span class=k>if</span><span class=w> </span><span class=n>delta_row</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=n>delta_col</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>				</span><span class=k>continue</span><span class=p>;</span><span class=w>
</span><span class=w>			</span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>			</span><span class=kd>let</span><span class=w> </span><span class=n>neighbour_row</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=n>row</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>delta_row</span><span class=p>)</span><span class=w> </span><span class=o>%</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>height</span><span class=p>;</span><span class=w>
</span><span class=w>			</span><span class=kd>let</span><span class=w> </span><span class=n>neighbour_col</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=n>column</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>delta_col</span><span class=p>)</span><span class=w> </span><span class=o>%</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>width</span><span class=p>;</span><span class=w>
</span><span class=w>			</span><span class=kd>let</span><span class=w> </span><span class=n>idx</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>get_index</span><span class=p>(</span><span class=n>neighbour_row</span><span class=p>,</span><span class=w> </span><span class=n>neighbour_col</span><span class=p>);</span><span class=w>
</span><span class=w>			</span><span class=n>count</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>cells</span><span class=p>[</span><span class=n>idx</span><span class=p>]</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=kt>u8</span><span class=p>;</span><span class=w>
</span><span class=w>		</span><span class=p>}</span><span class=w>
</span><span class=w>	</span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>	</span><span class=n>count</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>This code comes straight from the WASM rust book and it applies Conway&rsquo;s Game Of Life rules to our universe while also taking care of edge wrapping so that our universe seems looped (<a href=https://rustwasm.github.io/docs/book/game-of-life/implementing.html target=_blank rel="noopener noreffer">See flavour 3</a>).
Before we can use <code>tick</code>, we need to prepare our terminal to display animated game Universe. Let&rsquo;s hop into that right now!</p><p>P.S. - You can find source code for this chapter on my <a href=https://github.com/jbarszczewski/cli-game-of-life/tree/42c60e1c10073dd65819af7d1a6d7b049d1a449d target=_blank rel="noopener noreffer">GitHub</a></p><h1 id=animate-the-universe>Animate The Universe</h1><p>To work with terminal input/output we will use <a href=https://crates.io/crates/crossterm target=_blank rel="noopener noreffer">Crossterm crate</a>, so let&rsquo;s add it to our <code>Cargo.toml</code>:</p><div class=highlight><pre class=chroma><code class=language-yaml data-lang=yaml><span class=p>[</span><span class=l>dependencies]</span><span class=w>
</span><span class=w></span><span class=l>crossterm = &#34;0.19.0&#34;</span><span class=w>
</span></code></pre></div><p>This crate has some really handy functions to manipulate terminal and it&rsquo;s cross platform so we don&rsquo;t need to worry about any differences. Most of the crossterm commands are self-explanatory as they are grouped into relevan modules, like <code>cursor::Hide</code> does exactly what it says: it hides the cursor.</p><p>Because our game Universe will be updated and displayed in a loop, we want to clear the screen before each tick. We will move into the alternate screen for the game time and go back to original terminal screen once we are done. First let&rsquo;s make sure we have all the necessery imports:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>use</span><span class=w> </span><span class=n>crossterm</span>::<span class=p>{</span><span class=w>
</span><span class=w>	</span><span class=n>cursor</span>::<span class=p>{</span><span class=n>Hide</span><span class=p>,</span><span class=w> </span><span class=n>MoveTo</span><span class=p>,</span><span class=w> </span><span class=n>Show</span><span class=p>},</span><span class=w>
</span><span class=w>	</span><span class=n>event</span>::<span class=p>{</span><span class=n>poll</span><span class=p>,</span><span class=w> </span><span class=n>read</span><span class=p>,</span><span class=w> </span><span class=n>Event</span><span class=p>},</span><span class=w>
</span><span class=w>	</span><span class=n>execute</span><span class=p>,</span><span class=w>
</span><span class=w>	</span><span class=n>style</span>::<span class=p>{</span><span class=n>Color</span><span class=p>,</span><span class=w> </span><span class=n>Print</span><span class=p>,</span><span class=w> </span><span class=n>ResetColor</span><span class=p>,</span><span class=w> </span><span class=n>SetForegroundColor</span><span class=p>},</span><span class=w>
</span><span class=w>	</span><span class=n>terminal</span>::<span class=p>{</span><span class=n>Clear</span><span class=p>,</span><span class=w> </span><span class=n>ClearType</span><span class=p>,</span><span class=w> </span><span class=n>EnterAlternateScreen</span><span class=p>,</span><span class=w> </span><span class=n>LeaveAlternateScreen</span><span class=p>},</span><span class=w>
</span><span class=w>	</span><span class=nb>Result</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>};</span><span class=w>
</span><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>io</span>::<span class=n>stdout</span><span class=p>;</span><span class=w>
</span><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>time</span>::<span class=n>Duration</span><span class=p>;</span><span class=w>
</span></code></pre></div><p>Also, our <code>main</code> function need complete overhaul and now will look like this:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span>-&gt; <span class=nb>Result</span><span class=o>&lt;</span><span class=p>()</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>	</span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>game</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>game</span>::<span class=n>Universe</span>::<span class=n>new</span><span class=p>(</span><span class=mi>5</span><span class=p>,</span><span class=w> </span><span class=mi>5</span><span class=p>);</span><span class=w>
</span><span class=w>	</span><span class=n>game</span><span class=p>.</span><span class=n>set_cells</span><span class=p>(</span><span class=o>&amp;</span><span class=p>[(</span><span class=mi>2</span><span class=p>,</span><span class=w> </span><span class=mi>1</span><span class=p>),</span><span class=w> </span><span class=p>(</span><span class=mi>2</span><span class=p>,</span><span class=w> </span><span class=mi>2</span><span class=p>),</span><span class=w> </span><span class=p>(</span><span class=mi>2</span><span class=p>,</span><span class=w> </span><span class=mi>3</span><span class=p>)]);</span><span class=w>
</span><span class=w>	</span><span class=n>execute</span><span class=o>!</span><span class=p>(</span><span class=w>
</span><span class=w>		</span><span class=n>stdout</span><span class=p>(),</span><span class=w>
</span><span class=w>		</span><span class=n>EnterAlternateScreen</span><span class=p>,</span><span class=w>
</span><span class=w>		</span><span class=n>SetForegroundColor</span><span class=p>(</span><span class=n>Color</span>::<span class=n>Magenta</span><span class=p>),</span><span class=w>
</span><span class=w>		</span><span class=n>Hide</span><span class=w>
</span><span class=w>	</span><span class=p>)</span><span class=o>?</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w>	</span><span class=k>loop</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>		</span><span class=k>if</span><span class=w> </span><span class=n>poll</span><span class=p>(</span><span class=n>Duration</span>::<span class=n>from_millis</span><span class=p>(</span><span class=mi>500</span><span class=p>))</span><span class=o>?</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>			</span><span class=k>match</span><span class=w> </span><span class=n>read</span><span class=p>()</span><span class=o>?</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>				</span><span class=n>Event</span>::<span class=n>Key</span><span class=p>(</span><span class=n>_</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=k>break</span><span class=p>,</span><span class=w>
</span><span class=w>				</span><span class=n>_</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{}</span><span class=w>
</span><span class=w>			</span><span class=p>}</span><span class=w>
</span><span class=w>		</span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>			</span><span class=n>execute</span><span class=o>!</span><span class=p>(</span><span class=w>
</span><span class=w>				</span><span class=n>stdout</span><span class=p>(),</span><span class=w>
</span><span class=w>				</span><span class=n>Clear</span><span class=p>(</span><span class=n>ClearType</span>::<span class=n>All</span><span class=p>),</span><span class=w>
</span><span class=w>				</span><span class=n>MoveTo</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=p>),</span><span class=w>
</span><span class=w>				</span><span class=n>Print</span><span class=p>(</span><span class=o>&amp;</span><span class=n>game</span><span class=p>),</span><span class=w>
</span><span class=w>				</span><span class=n>Print</span><span class=p>(</span><span class=s>&#34;Press enter to exit...&#34;</span><span class=p>)</span><span class=w>
</span><span class=w>			</span><span class=p>)</span><span class=o>?</span><span class=p>;</span><span class=w>
</span><span class=w>			</span><span class=n>game</span><span class=p>.</span><span class=n>tick</span><span class=p>();</span><span class=w>
</span><span class=w>		</span><span class=p>}</span><span class=w>
</span><span class=w>	</span><span class=p>}</span><span class=w>
</span><span class=w>	</span><span class=n>execute</span><span class=o>!</span><span class=p>(</span><span class=n>stdout</span><span class=p>(),</span><span class=w> </span><span class=n>ResetColor</span><span class=p>,</span><span class=w> </span><span class=n>Show</span><span class=p>,</span><span class=w> </span><span class=n>LeaveAlternateScreen</span><span class=p>)</span><span class=o>?</span><span class=p>;</span><span class=w>
</span><span class=w>	</span><span class=nb>Ok</span><span class=p>(())</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>Ok let&rsquo;s break down what we did here:</p><ol><li><code>main</code> now returns Result type. This will allow us to provide feedback to users and set appropriate exit codes where needed.</li><li>We set up our terminal in <code>execute!</code> macro, which accepts <code>std::io::Writer</code> type (stdout in our case) as first argument followed by one or more commands.</li><li>In a loop we try to read the user input wrapped in a <code>poll</code> which ensure that we don&rsquo;t block the execution. We break the loop when user press the Enter key. If no user input is available in 500ms then we draw current state of the Universe and compute next state with <code>tick()</code></li><li>Once the loop is over, we leave the alternate screen of the terminal.</li></ol><p>Now run the app with <code>cargo run</code> and you should see simple pattern alternating between horizontal and vertical lines.
Ok but pressing Enter is not what user expect when trying to exit the app. Let&rsquo;s modify our code so that it could respond to different keys.</p><h1 id=interact-with-the-universe>Interact with The Universe</h1><p>Reason we could only process Enter is that by default input is being processed on enter press. Which makes sense as usually you first want to type in the command and execute when it&rsquo;s all ready. But in our case, we want user to be able to interact with single key presses. That means we need to enable <a href=https://docs.rs/crossterm/0.19.0/crossterm/terminal/#raw-mode target=_blank rel="noopener noreffer">raw mode</a>. New code changes are as follow:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=c1>// add required imports:
</span><span class=c1></span><span class=k>use</span><span class=w> </span><span class=n>terminal</span>::<span class=p>{</span><span class=n>disable_raw_mode</span><span class=p>,</span><span class=w> </span><span class=n>enable_raw_mode</span><span class=p>};</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=c1>// add this line at the very begining of the main() function:
</span><span class=c1></span><span class=n>enable_raw_mode</span><span class=p>()</span><span class=o>?</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=c1>// replace code block when poll returns true, the match statement, with following:
</span><span class=c1></span><span class=w>
</span><span class=w></span><span class=k>if</span><span class=w> </span><span class=kd>let</span><span class=w> </span><span class=n>Event</span>::<span class=n>Key</span><span class=p>(</span><span class=n>KeyEvent</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>code</span><span class=p>,</span><span class=w> </span><span class=p>..</span><span class=w> </span><span class=p>})</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>read</span><span class=p>()</span><span class=o>?</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>	</span><span class=k>match</span><span class=w> </span><span class=n>code</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>		</span><span class=n>KeyCode</span>::<span class=n>Esc</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>			</span><span class=k>break</span><span class=p>;</span><span class=w>
</span><span class=w>		</span><span class=p>}</span><span class=w>
</span><span class=w>		</span><span class=n>_</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{}</span><span class=w>
</span><span class=w>	</span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=c1>// finaly disable raw mode at the end of the function before returning Ok(()):
</span><span class=c1></span><span class=n>disable_raw_mode</span><span class=p>()</span><span class=o>?</span><span class=p>;</span><span class=w>
</span></code></pre></div><p>It&rsquo;s very important to add ability to exit from the loop as raw mode disables ctrl+c funcionality.</p><p>When you will try to run it now you will notice that formatting is all messed up. That&rsquo;s because raw mode doesn&rsquo;t process new line character. We need now explicitly set the cursor to the correct positions. That also means we cannot use the Display trait anymore. Instead, we will iterate through each row of the game Universe and print it out separately.</p><p>Add new method to the Universe:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>row_as_string</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>row</span>: <span class=kt>u32</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Option</span><span class=o>&lt;</span><span class=nb>String</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=n>row</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>height</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>		</span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>row_string</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>String</span>::<span class=n>new</span><span class=p>();</span><span class=w>
</span><span class=w>		</span><span class=kd>let</span><span class=w> </span><span class=n>start</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>get_index</span><span class=p>(</span><span class=n>row</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=p>);</span><span class=w>
</span><span class=w>		</span><span class=kd>let</span><span class=w> </span><span class=n>end</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>get_index</span><span class=p>(</span><span class=n>row</span><span class=p>,</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>width</span><span class=p>);</span><span class=w>
</span><span class=w>		</span><span class=kd>let</span><span class=w> </span><span class=n>line</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=bp>self</span><span class=p>.</span><span class=n>cells</span><span class=p>[</span><span class=n>start</span><span class=p>..</span><span class=n>end</span><span class=p>];</span><span class=w>
</span><span class=w>		</span><span class=k>for</span><span class=w> </span><span class=o>&amp;</span><span class=n>cell</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=n>line</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>			</span><span class=kd>let</span><span class=w> </span><span class=n>symbol</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>if</span><span class=w> </span><span class=n>cell</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>Cell</span>::<span class=n>Dead</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=sc>&#39;◻&#39;</span><span class=w> </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=sc>&#39;◼&#39;</span><span class=w> </span><span class=p>};</span><span class=w>
</span><span class=w>			</span><span class=n>row_string</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=n>symbol</span><span class=p>);</span><span class=w>
</span><span class=w>		</span><span class=p>}</span><span class=w>
</span><span class=w>		</span><span class=nb>Some</span><span class=p>(</span><span class=n>row_string</span><span class=p>)</span><span class=w>
</span><span class=w>	</span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>		</span><span class=nb>None</span><span class=w>
</span><span class=w>	</span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>If the row is withing Universe size we will return all its cells as a String, otherwise <code>None</code> is returned.
In our <code>main.rs</code> add new import from crossterm <code>queue</code>, <code>queue!</code> macro is similar to <code>execute</code> but require manual flush. This makes it really handy if you want to conditionaly build your output. Let&rsquo;s see how it goes. First at the beginning of our <code>main()</code> function initialize a new variable:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>stdout</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>stdout</span><span class=p>();</span><span class=w>
</span></code></pre></div><p>Now you can replace <code>stdout()</code> with our new variable name for consistency. Then replace the whole <code>loop</code> with following code:</p><div class=highlight><pre class=chroma><code class=language-rust data-lang=rust><span class=k>loop</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=n>poll</span><span class=p>(</span><span class=n>Duration</span>::<span class=n>from_millis</span><span class=p>(</span><span class=mi>500</span><span class=p>))</span><span class=o>?</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>		</span><span class=k>if</span><span class=w> </span><span class=kd>let</span><span class=w> </span><span class=n>Event</span>::<span class=n>Key</span><span class=p>(</span><span class=n>KeyEvent</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>code</span><span class=p>,</span><span class=w> </span><span class=p>..</span><span class=w> </span><span class=p>})</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>read</span><span class=p>()</span><span class=o>?</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>			</span><span class=k>match</span><span class=w> </span><span class=n>code</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>				</span><span class=n>KeyCode</span>::<span class=n>Esc</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>					</span><span class=k>break</span><span class=p>;</span><span class=w>
</span><span class=w>				</span><span class=p>}</span><span class=w>
</span><span class=w>				</span><span class=n>_</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{}</span><span class=w>
</span><span class=w>			</span><span class=p>}</span><span class=w>
</span><span class=w>		</span><span class=p>}</span><span class=w>
</span><span class=w>	</span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>		</span><span class=n>queue</span><span class=o>!</span><span class=p>(</span><span class=n>stdout</span><span class=p>,</span><span class=w> </span><span class=n>Clear</span><span class=p>(</span><span class=n>ClearType</span>::<span class=n>All</span><span class=p>))</span><span class=o>?</span><span class=p>;</span><span class=w>
</span><span class=w>		</span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w>
</span><span class=w>		</span><span class=k>while</span><span class=w> </span><span class=kd>let</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=n>line</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>game</span><span class=p>.</span><span class=n>row_as_string</span><span class=p>(</span><span class=n>i</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>			</span><span class=n>queue</span><span class=o>!</span><span class=p>(</span><span class=n>stdout</span><span class=p>,</span><span class=w> </span><span class=n>MoveTo</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=kt>u16</span><span class=p>),</span><span class=w> </span><span class=n>Print</span><span class=p>(</span><span class=n>line</span><span class=p>))</span><span class=o>?</span><span class=p>;</span><span class=w>
</span><span class=w>			</span><span class=n>i</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w>
</span><span class=w>		</span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>		</span><span class=n>queue</span><span class=o>!</span><span class=p>(</span><span class=w>
</span><span class=w>			</span><span class=n>stdout</span><span class=p>,</span><span class=w>
</span><span class=w>			</span><span class=n>MoveTo</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=p>(</span><span class=n>i</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=mi>1</span><span class=p>)</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=kt>u16</span><span class=p>),</span><span class=w>
</span><span class=w>			</span><span class=n>Print</span><span class=p>(</span><span class=s>&#34;Press Esc to exit...&#34;</span><span class=p>)</span><span class=w>
</span><span class=w>		</span><span class=p>)</span><span class=o>?</span><span class=p>;</span><span class=w>
</span><span class=w>		</span><span class=n>stdout</span><span class=p>.</span><span class=n>flush</span><span class=p>()</span><span class=o>?</span><span class=p>;</span><span class=w>
</span><span class=w>		</span><span class=n>game</span><span class=p>.</span><span class=n>tick</span><span class=p>();</span><span class=w>
</span><span class=w>	</span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>The key press handling remains unchanged. All the changes are in <code>else</code> block:</p><ol><li>We&rsquo;ve replaced single <code>execute!</code> with <code>queue!</code> macros.</li><li>We iterate through game Universe rows while <code>row_as_string(i)</code> returns results and queue printing them on separate lines. You can see here how handy is to return <code>Option&lt;T></code>! We don&rsquo;t need any null handling and the code looks super clean.</li><li>After all text is ready, we <code>flush()</code> stdout.</li></ol><h1 id=conclusion>Conclusion</h1><p>And that&rsquo;s it for part 1! A good exercise would be to enhance the app with some more user interactions, like controlling speed or colours. In the next part I will cover how we can process command line arguments to set up our game.
I hope you&rsquo;ve enjoyed this tutorial and as always if any suggestions/questions don&rsquo;t hesitate to leave a comment below.</p><p>Thanks for reading and till the next time!</p></div><div class=post><div class=post-info-share><span></span></div><div class=post-footer id=post-footer><div class=post-navigation><div class="post-nav-box nav-box-prev"><a class=nav-box href=/posts/rust-actix-webapi/><span class=nav-icon><svg aria-hidden="true" data-prefix="fas" data-icon="chevron-circle-left" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M256 504C119 504 8 393 8 256S119 8 256 8s248 111 248 248-111 248-248 248zM142.1 273l135.5 135.5c9.4 9.4 24.6 9.4 33.9.0l17-17c9.4-9.4 9.4-24.6.0-33.9L226.9 256l101.6-101.6c9.4-9.4 9.4-24.6.0-33.9l-17-17c-9.4-9.4-24.6-9.4-33.9.0L142.1 239c-9.4 9.4-9.4 24.6.0 34z"/></svg></span><div style=text-align:right;padding-left:10px><div class=nav-text-h>Next article</div><span class=nav-text>Rust + Actix + CosmosDB (MongoDB) Web API tutorial</span></div></a></div></div></div></div></div><div id=toc-final></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line>Powered by <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.80.0">Hugo</a> | Theme - <a href="https://ublogger.netlify.app/?utm_source=https://jbarszczewski.com/&utm_medium=footer&utm_campaign=config&utm_term=1.2.0" target=_blank title="uBlogger 1.2.0"><i class="fas fa-pencil-alt fa-fw"></i>uBlogger</a></div><div class=footer-line><i class="far fa-copyright fa-fw"></i><span>2021</span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title="Back to Top"><i class="fas fa-arrow-up fa-fw"></i></a><a href=# id=view-comments class=fixed-button title="View Comments"><i class="fas fa-comment fa-fw"></i></a></div><script src=/lib/smooth-scroll/smooth-scroll.min.js></script><script src=/lib/lazysizes/lazysizes.min.js></script><script src=/lib/clipboard/clipboard.min.js></script><script>window.config={"code":{"copyTitle":"Copy to clipboard","maxShownLines":10}};</script><script src=/js/theme.min.js></script><script src=/js/jquery-3.5.1.min.js></script></body></html>